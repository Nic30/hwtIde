<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <title>elkjs d3 example ports</title>
  <script type="text/javascript" src="/static/node_modules/d3/build/d3.js"></script>
  <script type="text/javascript" src="/static/hls/connections_elk/elk.bundled.js"></script>
  <script type="text/javascript" src="/static/hls/connections_elk/elk-d3.js"></script>
  <style>
    text {
      font-family: monospace;
    }
    .node {
      stroke: #BDBDBD;
      stroke-width: 0px;
      fill: #A9D0F5;
      border: 1;
	  /*.attr("fill", "url(#blue_grad)")*/
    }
    
    .link {
      stroke: #000; /*#999;*/
      stroke-opacity: .6;
      fill: none;
    }
    
    .port {
      stroke: #000;
      opacity: .6;
    }
  </style>
  <script type="text/javascript">
     var MODULE_NAME = "{{MODULE_NAME}}";
     var IN_MODULE_NAME = "{{IN_MODULE_NAME}}";
     var PORT_HEIGHT = 20;
     var CHAR_WIDTH = 7.55;
     var NODE_MIDDLE_PORT_SPACING = 20;
  </script>
  
</head>
<body>
<script>
function viewport() {
  var e = window,
    a = 'inner';
  if (!('innerWidth' in window)) {
    a = 'client';
    e = document.documentElement || document.body;
  }
  return {
    width: e[a + 'Width'],
    height: e[a + 'Height']
  }
}
var width = viewport().width,
    height = viewport().height;
var zoom = d3.zoom()
    .on("zoom", redraw); 
var svg = d3.select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(zoom)
    .append("g");

var defs = svg.append("defs")


defs.append("g")
   .attr("id", "westInPortMarker")
   .append("path")
   .attr("d", "M 2 -4  7 1  2 6 Z")

defs.append("g")
   .attr("id", "westOutPortMarker")
   .append("path")
   .attr("d", "M 7 -4  2 1  7 6 Z")

defs.append("g")
   .attr("id", "eastInPortMarker")
   .append("path")
   .attr("d", "M 0 -5  -5 0  0 5 Z")

defs.append("g")
   .attr("id", "eastOutPortMarker")
   .append("path")
   .attr("d", "M -5 -5  0 0  -5 5 Z")

function getIOMarker(d) {
	var side = d.properties.portSide;
	var portType = d.direction;

	if (side == "WEST") {
		if (portType == "INPUT") {
			return "#westInPortMarker";
		} else if (portType == "OUTPUT") {
			return "#westOutPortMarker";
		}
	} else if (side == "EAST") {
		if (portType == "INPUT") {
			return "#eastInPortMarker";
		} else if (portType == "OUTPUT") {
			return "#eastOutPortMarker";
		}
	}
	throw new Error("Wrong side, portType", side, portType)
}

function widthOfText(text) {
	if (text)
	    return text.length * CHAR_WIDTH;
	else
		return 0;
}

function initNodeSizes(d) {
    var labelW = widthOfText(d.name)
    var westCnt = 0;
    var eastCnt = 0;
	var portW = 0;
	var max = Math.max
	
    d.ports.forEach(function(p) {
    	var t = p.properties.portSide;
    	if (t == "WEST"){
    		westCnt++;	
    	} else if (t == "EAST") {
    		eastCnt++;
    	} else {
    		throw new Error(t);
    	}
    	portW = max(portW, widthOfText(p.name))
    })
    
    d.width = max(portW * 2 + NODE_MIDDLE_PORT_SPACING, labelW)
    d.height = max(westCnt, eastCnt) * PORT_HEIGHT;
}
   
var root = svg.append("g");
var layouter = elk.d3adapter();

// load the data and render the elements
d3.json("/hls/connections-data-elk/" + MODULE_NAME + "/" + IN_MODULE_NAME, function(error, graph) {
  if (error) {
    throw error;
  }
  graph.nodes.forEach(initNodeSizes);
  // config of layouter
  layouter
      .nodes(graph.nodes)
      .links(graph.links)
      .size([width, height])
      .transformGroup(root)
      .options({
        edgeRouting: "ORTHOGONAL",
      })
      .defaultPortSize([2, 2]) // size of port icon
      .start();
      
  var link = root.selectAll(".link")
      .data(graph.links)
      .enter()
      .append("path")
      .attr("class", "link")

  // by "g" we group nodes along with their ports
  var node = root.selectAll(".node")
      .data(graph.nodes)
      .enter()
      .append("g");

  var nodeBody = node.append("rect");
  
  var port = node.selectAll(".port")
      .data(function(d) { return d.ports; })
      .enter()
      .append("g");
  
  // apply layout
  layouter.on("finish", function(d) {
  
    // apply edge routes
    link.transition().attr("d", function(d) {
      var path = "";
      if (d.bendpoints || d.sections.length > 1) {
    	  throw new Error("NotImplemented");
      }
      
      return elk.section2svgPath(d.sections[0]);
    });
  
    // apply node positions
    node.transition()
      .duration(0)
      .attr("transform", function(d) { return "translate(" + d.x + " " + d.y + ")"});

    // apply port positions  
    port.transition()
      .duration(0)
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"});

  });
  
  layouter.start();

  // set dimensions and style of node
  nodeBody
      .attr("class", "node")
      .attr("width", function(d) { return d.width })
      .attr("height", function(d) { return d.height })
      .attr("rx", 5)
      .attr("ry", 5);

  // spot node label
  node.append("text")
      .text(function(d) { return d.name; });

  // spot port name
  port.append("text")
    .attr("y", PORT_HEIGHT/4)
    .text(function(d) { return d.name; })
    .attr("x", function(d) {
    	var side = d.properties.portSide;
    	if (side == "WEST") {
    	   return 5;
    	} else if (side == "EAST") {
    	   return -this.getBBox().width - 5;
    	} else {
    		throw new Error(side);
    	}
    });

  // spot input/output marker
  port.append("use")
      .attr("href", getIOMarker)

  // spot port connection pin
  port
    .append("rect")
    .attr("class", "port")
    .attr("width", function(d){ return d.width || 2  })
    .attr("height", function(d){ return d.height || 2 })


});
function redraw() {
  svg.attr("transform", d3.event.transform)
};
</script>